/*
 * @(#)CSVImporter.java
 * CubeTwister. Copyright Â© 2020 Werner Randelshofer, Switzerland. MIT License.
 */
package ch.randelshofer.rubik.impexp.csv;

import ch.randelshofer.cubetwister.doc.DocumentModel;
import ch.randelshofer.cubetwister.doc.MacroModel;
import ch.randelshofer.cubetwister.doc.ScriptModel;
import ch.randelshofer.gui.Fonts;
import ch.randelshofer.gui.ProgressObserver;
import ch.randelshofer.io.BoundedRangeReader;
import ch.randelshofer.io.CSVReader;
import ch.randelshofer.rubik.impexp.Importer;
import org.jhotdraw.annotation.Nonnull;
import org.jhotdraw.annotation.Nullable;

import javax.swing.DefaultCellEditor;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JPanel;
import java.awt.Font;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.util.ArrayList;

/**
 * CSVImporter.
 *
 * @author Werner Randelshofer
 */
public class CSVImporter extends JPanel implements Importer {
    private final static long serialVersionUID = 1L;

    private ColumnMappingTableModel columnMapping;
    private File previewFile;
    private DocumentModel documentModel;
    /**
     * The columns of the import data that can be imported by this importer into
     * CubeTwister.
     */
    public final static String[] supportedColumns = {
        "Name",
        "Notation",
        "Script",
        "Macros",
        "Notes",
        "Author",
        "Date",};
    /**
     * The indices of the elements in the array <code>supportedColumns</code>.
     */
    public final static int NAME_INDEX = 0,
            NOTATION_INDEX = 1,
            SCRIPT_INDEX = 2,
            MACROS_INDEX = 3,
            DESCRIPTION_INDEX = 4,
            AUTHOR_INDEX = 5,
            DATE_INDEX = 6;

    private char delimiterChar;

    /**
     * Creates new form.
     */
    public CSVImporter(char delimiterChar) {
        this.delimiterChar = delimiterChar;

        initComponents();
        Font f = Fonts.getSmallDialogFont();
        table.setFont(f);

        table.setModel(columnMapping = new ColumnMappingTableModel());
        columnMapping.setImportDataColumnTitles(supportedColumns);
        //Set up the renderer and the editor for the column mapping cells.
        //----------------------------------------------------------------
        table.getColumnModel().getColumn(1).setCellRenderer(new ColumnMappingCellRenderer());

        // We fill the combo box model with Integer objects. Each Integer objects
        // is an index in the supportedColumns array.
        Object[] items = new Object[supportedColumns.length + 1];
        for (int i = 0; i < items.length; i++) {
            items[i] = new Integer(i - 1);
        }
        JComboBox comboBox = new JComboBox(new DefaultComboBoxModel(items));
        comboBox.setRenderer(new ColumnMappingCellRenderer());
        table.getColumnModel().getColumn(1).setCellEditor(new DefaultCellEditor(comboBox));
    }

    private void updateView() {
        if (previewFile != null && previewFile.isFile()) {
            try {
                columnMapping.setImportDataColumnTitles(readColumnTitles(previewFile));
            } catch (IOException e) {
                //inputListModel.add(e);
                columnMapping.clear();
            }
            setEnabled(true);
        } else {
            setEnabled(false);
        }
    }

    @Nullable
    private String[] readColumnTitles(@Nullable File f) throws IOException {
        if (f == null) {
            return new String[0];
        }

        String[] columnTitles;
        CSVReader in = null;
        try {
            in = new CSVReader(new BufferedReader(new InputStreamReader(new FileInputStream(f), "ISO-8859-1")), delimiterChar, '"');
            columnTitles = in.readln();
        } finally {
            if (in != null) {
                in.close();
            }
        }
        return columnTitles;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        scrollPane = new javax.swing.JScrollPane();
        table = new javax.swing.JTable();
        columnsLabel = new javax.swing.JLabel();

        setLayout(new java.awt.BorderLayout());

        scrollPane.setViewportView(table);

        add(scrollPane, java.awt.BorderLayout.CENTER);

        columnsLabel.setText("Column mapping:");
        add(columnsLabel, java.awt.BorderLayout.NORTH);

    }//GEN-END:initComponents

    @Nonnull
    @Override
    public ArrayList<ScriptModel> importFile(@Nonnull File file, @Nonnull ProgressObserver p) throws IOException {
        int[] columnIndices = columnMapping.getColumnMapping();

        CSVReader in = null;
        try {/*
             BoundedRangeInputStream bris;
             bris = new BoundedRangeInputStream(file, true);
             p.setModel(bris);
             in = new CSVReader(new InputStreamReader(bris), delimiterChar, '"');
             */

            BoundedRangeReader bris;
            bris = new BoundedRangeReader(file, true);
            p.setModel(bris);
            in = new CSVReader(bris, delimiterChar, '"');
            ArrayList<ScriptModel> result = new ArrayList<ScriptModel>();

            String[] columns;
            // Skip the first line
            in.readln();

            // Read all subsequent lines
            int lineNumber = 0;
            while ((columns = in.readln()) != null) {
                p.setNote("Importing line " + (++lineNumber) + "...");
                result.add(importScript(columns, columnIndices));
            }
            return result;
        } finally {
            if (in != null) {
                in.close();
            }
        }
    }

    @Nonnull
    private ScriptModel importScript(@Nonnull String[] columns, int[] columnIndices)
            throws IOException {
        ScriptModel item = new ScriptModel();

        int index;
        index = columnIndices[NAME_INDEX];
        if (index != -1 && columns.length > index) {
            item.setName(columns[index]);
        }
        index = columnIndices[SCRIPT_INDEX];
        if (index != -1 && columns.length > index) {
            item.setScript(columns[index]);
        }
        index = columnIndices[DESCRIPTION_INDEX];
        if (index != -1 && columns.length > index) {
            item.setDescription(columns[index]);
        }
        index = columnIndices[AUTHOR_INDEX];
        if (index != -1 && columns.length > index) {
            item.setAuthor(columns[index]);
        }
        index = columnIndices[DATE_INDEX];
        if (index != -1 && columns.length > index) {
            item.setDate(columns[index]);
        }
        index = columnIndices[MACROS_INDEX];
        if (index != -1 && columns.length > index) {
            String macros = columns[index];
            if (macros != null && macros.length() > 0) {
                CSVReader macroIn = new CSVReader(new StringReader(macros), '=', '"');
                String[] macroColumns;
                while ((macroColumns = macroIn.readln()) != null) {
                    MacroModel macro = new MacroModel();
                    macro.setIdentifier(macroColumns[0]);
                    macro.setScript(macroColumns[1]);
                    item.getMacroModels().add(macro);
                }
            }
        }

        return item;
    }

    public void setDocumentModel(DocumentModel model) {
        this.documentModel = model;
    }

    public void setPreviewFile(File file) {
        this.previewFile = file;
        updateView();
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel columnsLabel;
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JTable table;
    // End of variables declaration//GEN-END:variables

    @Nonnull
    @Override
    public JComponent getComponent() {
        return this;
    }

}
