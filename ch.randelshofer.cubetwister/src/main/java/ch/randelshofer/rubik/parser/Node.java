/*
 * @(#)Node.java
 * CubeTwister. Copyright Â© 2020 Werner Randelshofer, Switzerland. MIT License.
 */
package ch.randelshofer.rubik.parser;

import ch.randelshofer.gui.tree.TreeNodeImpl;
import ch.randelshofer.rubik.cube.Cube;
import ch.randelshofer.rubik.notation.Notation;
import ch.randelshofer.rubik.notation.Symbol;
import ch.randelshofer.util.ReverseListIterator;
import org.jhotdraw.annotation.Nonnull;
import org.jhotdraw.annotation.Nullable;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * Abstract superclass for a Node in the parse tree generated by the Parser.
 *
 * @author Werner Randelshofer
 */
public abstract class Node extends TreeNodeImpl<Node> {
    private static final long serialVersionUID = 1L;

    /**
     * The start position of this node in the source.
     */
    protected int startpos;
    /**
     * The end position of this node in the source.
     */
    protected int endpos;

    public Node() {
    }

    public Node(int startpos, int endpos) {
        this.startpos = startpos;
        this.endpos = endpos;
    }

    public void addAll(@Nonnull List<Node> children) {
        for (Node n : children) {
            add(n);
        }
    }

    /**
     * Returns the start position of the symbol in the source code.
     */
    public int getStartPosition() {
        return startpos;
    }

    /**
     * Sets the start position of the symbol in the source code.
     */
    public void setStartPosition(int p) {
        startpos = p;
    }

    /**
     * Returns the end position of the symbol in the source code.
     */
    public int getEndPosition() {
        return endpos;
    }

    /**
     * Sets the end position of the symbol in the source code.
     */
    public void setEndPosition(int p) {
        endpos = p;
    }

    /**
     * Applies the symbol represented by this node to the cube.
     *
     * @param cube A cube to be transformed by this symbol.
     */
    public void applyTo(Cube cube) {
        applyTo(cube, false);
    }

    /**
     * Applies the symbol represented by this node to the cube.
     *
     * @param cube    A cube to be transformed by this symbol.
     * @param inverse If true, the transform will be done in inverse order.
     */
    public void applyTo(Cube cube, boolean inverse) {
        for (Node node : resolvedIterable(inverse)) {
            node.applyTo(cube, false);
        }
    }

    @Override
    public String toString() {
        StringBuilder b = new StringBuilder();
        b.append(getStartPosition());
        b.append("..");
        b.append(getEndPosition());
        b.append(getClass().getSimpleName());
        b.append("{");
        for (Node n : getChildren()) {
            b.append(' ');
            b.append(n.toString());
        }
        b.append(' ');
        b.append("}");
        return b.toString();
    }

    /**
     * Returns a string representation of this node using the specified
     * notation.
     */
    public final String toString(@Nonnull Notation notation) throws IOException {
        return toString(notation, null);
    }

    /**
     * Returns a string representation of this node using the specified notation
     * and the specified local macros.
     */
    public final String toString(@Nonnull Notation notation, @Nullable List<MacroNode> localMacros) throws IOException {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);

        HashMap<String, MacroNode> macroMap = new HashMap<String, MacroNode>();
        if (localMacros != null) {
            for (MacroNode mn : localMacros) {
                macroMap.put(mn.getIdentifier(), mn);
            }
        }

        writeTokens(pw, notation, macroMap);
        pw.close();
        return sw.toString();
    }

    /**
     * Transformes the subtree starting at this node by the given move. Does
     * nothing if the transformation can not be done.
     */
    public void transform(int axis, int layerMask, int angle) {
        for (Node elem : getChildren()) {
            elem.transform(axis, layerMask, angle);
        }
    }

    public void transform(@Nonnull MoveNode move, boolean inverse) {
        transform(move.getAxis(), move.getLayerMask(), (inverse) ? -move.getAngle() : move.getAngle());
    }


    /**
     * Inverses the subtree starting at this node.
     */
    @SuppressWarnings("unchecked")
    public void invert() {
        if (children != null) {
            List<Node> l = new ArrayList<>(getChildren());
            removeAllChildren();
            for (int i = l.size() - 1; i >= 0; i--) {
                Node elem = l.get(i);
                elem.invert();
                this.add(elem);
            }
        }
    }

    /**
     * Reflects the subtree starting at this node.
     */
    public void reflect() {
        if (children != null) {
            for (Node elem : getChildren()) {
                elem.reflect();
            }
        }
    }

    /**
     * Enumerates a resolved version of the subtree starting at this node. All
     * elements of the enumeration contain only atomic operations on a cube
     * such as from a {@link MoveNode} or a {@link PermutationCycleNode}.
     *
     * @param inverse Set to true if you wish to get an inverted enumeration.
     */
    public Iterator<Node> resolvedIterator(boolean inverse) {
        return new ResolvedIterator(this, inverse);
    }

    @Nonnull
    public Iterable<Node> resolvedIterable(final boolean inverse) {
        return () -> resolvedIterator(inverse);
    }

    @Nonnull
    public Stream<Node> resolvedStream(final boolean inverse) {
        return StreamSupport.stream(Spliterators.spliterator(resolvedIterator(inverse), Long.MAX_VALUE, Spliterator.IMMUTABLE | Spliterator.NONNULL), false);
    }

    @Nonnull
    public List<Node> toResolvedList(boolean inverse) {
        List<Node> list = new ArrayList<>();
        resolvedIterator(inverse).forEachRemaining(list::add);
        return list;
    }

    @Nonnull
    @SuppressWarnings("unchecked")
    public Iterator<Node> childIterator() {
        Iterator<Node> empty = ((List) Collections.emptyList()).iterator();
        return children == null ? empty : (Iterator<Node>) (Iterator<?>) children.iterator();
    }

    /**
     * Enumerates the direct children of this node in reverse order.
     */
    @SuppressWarnings("unchecked")
    public Iterator<Node> reversedChildIterator() {
        Iterator<Node> empty = ((List) Collections.emptyList()).iterator();
        return (children == null) ? empty : new ReverseListIterator<Node>((List<Node>) (List<?>) children);
    }

    /**
     * The resolved iteration.
     */
    private static class ResolvedIterator
            implements Iterator<Node> {

        /**
         * Enumeration of the direct children of this node.
         */
        private Iterator<Node> children;
        /**
         * Subtree at the current child.
         */
        private Iterator<Node> current;
        /**
         * True when enumeration has to be inverse.
         */
        private final boolean inverse;

        public ResolvedIterator(@Nonnull Node root, boolean inverse) {
            this.inverse = inverse;
            children = (inverse) ? root.reversedChildIterator() : root.childIterator();
            current = Collections.emptyIterator();
        }

        private boolean move() {
            if (current.hasNext()) {
                return true;
            } else {
                while (children.hasNext()) {
                    current = children.next().resolvedIterator(inverse);
                    if (current.hasNext()) {
                        return true;
                    }
                }
                return false;
            }
        }

        @Override
        public boolean hasNext() {
            return current.hasNext() || move();
        }

        @Override
        public Node next() {
            move();
            return current.next();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * Writes the token(s) represented by the subtree starting at this node. The
     * syntax and the string representations of the tokens are provided by the
     * parser.
     *
     * @param w        This is where the tokens are written to.
     * @param n        The notation which provides the tokens.
     * @param macroMap Local macros which are preserved by the translation.
     */
    public void writeTokens(Writer w, @Nonnull Notation n, Map<String, MacroNode> macroMap)
            throws IOException {
        // FIXME - Implement macro coercion
        String macroName = null; // n.getEquivalentMacro(cube, macroMap);
        if (macroName != null) {
            w.write(macroName);
        } else {
            Iterator<Node> enumer = getChildren().iterator();
            while (enumer.hasNext()) {
                enumer.next().writeTokens(w, n, macroMap);
                if (enumer.hasNext()) {
                    try {
                        n.writeToken(w, Symbol.DELIMITER);
                    } catch (IOException e) {
                        // ignore no token for delimiter
                    }
                    w.write(' ');
                }
            }
        }
    }

    /**
     * Returns a deep clone of the subtree starting at this node.
     */
    public Node cloneSubtree() {
        Node that = clone();
        for (Node child : getChildren()) {
            that.add(child.cloneSubtree());
        }
        return that;
    }
}
