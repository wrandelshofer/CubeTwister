/* @(#)RubiksCubeSolverDemo.java
 * Copyright (c) 2009 Werner Randelshofer, Switzerland. MIT License.
 */
package demos;

import ch.randelshofer.gui.ProgressObserver;
import ch.randelshofer.gui.ProgressView;
import ch.randelshofer.io.ParseException;
import ch.randelshofer.rubik.Cube3DCanvas;
import ch.randelshofer.rubik.Cube3DCanvasIdx3D;
import ch.randelshofer.rubik.DefaultCubeAttributes;
import ch.randelshofer.rubik.cube.Cubes;
import ch.randelshofer.rubik.cube.RubiksCube;
import ch.randelshofer.rubik.cube3d.Cube3DEvent;
import ch.randelshofer.rubik.cube3d.Cube3DListener;
import ch.randelshofer.rubik.cube3d.RubiksCubeIdx3D;
import ch.randelshofer.rubik.notation.DefaultNotation;
import ch.randelshofer.rubik.notation.Notation;
import ch.randelshofer.rubik.parser.Node;
import ch.randelshofer.rubik.parser.ScriptParser;
import ch.randelshofer.rubik.parser.SequenceNode;
import ch.randelshofer.rubik.solver.CubeParser;
import ch.randelshofer.rubik.solver.FaceletCube;
import ch.randelshofer.rubik.solver.KociembaCube;
import ch.randelshofer.rubik.solver.Solver;
import ch.randelshofer.util.RunnableWorker;
import org.jhotdraw.annotation.Nonnull;
import org.jhotdraw.annotation.Nullable;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import java.io.IOException;

/**
 * A JPanel with an interactive Rubik's Cube, a script field and a solver.
 *
 * @author Werner Randelshofer
 */
public class RubiksCubeSolverDemo extends javax.swing.JPanel {
    private final static long serialVersionUID = 1L;

    @Nonnull
    private Notation notation = new DefaultNotation();
    private Cube3DCanvas canvas;
    private RubiksCubeIdx3D cube3d;
    private RubiksCube cube;

    /** Creates new form RubiksCubeSolverDemo */
    public RubiksCubeSolverDemo() {
        // Initializes the components and adds them to the panel
        initComponents();

        // Creates a 3D model of the Rubik's Cube for the Idx3D rendering engine,
        // and turns animation on.
        cube3d = new RubiksCubeIdx3D();
        cube3d.setAnimated(true);

        // Create a mathematical model of a Rubik's Cube and plugs it into
        // the 3D model.
        // Note: this is not necessary, since the constructor of RubiksCubeIdx3D
        // does this already.
        cube = new RubiksCube();
        cube3d.setCube(cube);

        // Add a listener to the 3D cube, which twists the cube when clicked
        cube3d.addCube3DListener(new Cube3DListener() {

            public void actionPerformed(@Nonnull Cube3DEvent evt) {
                if (isEnabled()) {
                    evt.applyTo(evt.getCube3D().getCube());
                }
            }

            public void mouseEntered(Cube3DEvent evt) {
            }

            public void mouseExited(Cube3DEvent evt) {
            }

            public void mousePressed(Cube3DEvent evt) {
            }

            public void mouseReleased(Cube3DEvent evt) {
            }
        });

        // Orient the cube so that the faces front, up and right are visible
        DefaultCubeAttributes attr = (DefaultCubeAttributes) cube3d.getAttributes();
        attr.setAlpha((float) (Math.PI / -8f));
        attr.setBeta((float) (Math.PI / 4f));
        //attr.setStickerFillColor(0, Color.GREEN);

        // Create a cube 3D canvas with the Idx3d rendering engine and add
        // the cube to it.
        canvas = new Cube3DCanvasIdx3D();
        canvas.setCube3D(cube3d);

        // Disable all interaction with the 3D canvas
        //canvas.setEnabled(false);

        // Add the canvas to the panel
        add(canvas.getVisualComponent());

    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                JFrame f = new JFrame("CubeTwister Rubik's Cube Solver Demo");
                f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                f.add(new RubiksCubeSolverDemo());
                f.setSize(400, 400);
                f.setVisible(true);
            }
        });
    }

    public void setEnabled(boolean b) {
        super.setEnabled(b);
        canvas.setEnabled(b);
        applyButton.setEnabled(b);
        resetButton.setEnabled(b);
        solveButton.setEnabled(b);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        scriptPanel = new javax.swing.JPanel();
        scriptScrollPane = new javax.swing.JScrollPane();
        scriptField = new javax.swing.JTextArea();
        applyButton = new javax.swing.JButton();
        solveButton = new javax.swing.JButton();
        resetButton = new javax.swing.JButton();

        FormListener formListener = new FormListener();

        setLayout(new java.awt.BorderLayout());

        scriptPanel.setLayout(new java.awt.GridBagLayout());

        scriptField.setColumns(20);
        scriptField.setLineWrap(true);
        scriptField.setRows(5);
        scriptField.setText("R2 R L B R2");
        scriptField.setWrapStyleWord(true);
        scriptScrollPane.setViewportView(scriptField);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridheight = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        scriptPanel.add(scriptScrollPane, gridBagConstraints);

        applyButton.setText("Apply");
        applyButton.addActionListener(formListener);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(10, 10, 0, 10);
        scriptPanel.add(applyButton, gridBagConstraints);

        solveButton.setText("Solve");
        solveButton.addActionListener(formListener);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(10, 10, 0, 10);
        scriptPanel.add(solveButton, gridBagConstraints);

        resetButton.setText("Reset");
        resetButton.addActionListener(formListener);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(10, 10, 10, 10);
        scriptPanel.add(resetButton, gridBagConstraints);

        add(scriptPanel, java.awt.BorderLayout.PAGE_END);
    }

    // Code for dispatching events from components to event handlers.

    private class FormListener implements java.awt.event.ActionListener {
        FormListener() {
        }

        public void actionPerformed(@Nonnull java.awt.event.ActionEvent evt) {
            if (evt.getSource() == applyButton) {
                RubiksCubeSolverDemo.this.apply(evt);
            } else if (evt.getSource() == solveButton) {
                RubiksCubeSolverDemo.this.solve(evt);
            } else if (evt.getSource() == resetButton) {
                RubiksCubeSolverDemo.this.reset(evt);
            }
        }
    }// </editor-fold>//GEN-END:initComponents

    /** This method is called when the apply button has been pressed.
     * Applies the script in the script field to the cube.
     */
    private void apply(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_apply
        setEnabled(false);

        ScriptParser parser = new ScriptParser(notation);
        try {
            final Node script = parser.parse(scriptField.getText());

            new Thread(new RunnableWorker() {

                @Nullable
                @Override
                public Object construct() {
                    script.applyTo(cube, false);
                    return null;
                }

                @Override
                public void finished(Object result) {
                    setEnabled(true);
                }
            }).start();

        } catch (IOException e) {
            JOptionPane.showMessageDialog(
                    RubiksCubeSolverDemo.this,
                    "<html><font face=Dialog><b>Script Error</b><br><font size=-1>" + e.getMessage(),
                    "Apply",
                    JOptionPane.ERROR_MESSAGE);
        }

    }//GEN-LAST:event_apply

    private void reset(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_reset
        cube.reset();
        canvas.reset();
    }//GEN-LAST:event_reset

    private void solve(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_solve
        final RubiksCube rcube = (RubiksCube) cube.clone();

        final ProgressObserver progressMonitor = new ProgressView("Solving Cube", "Waiting for Processor...", 0, Integer.MAX_VALUE);

        setEnabled(false);
        RunnableWorker worker = new RunnableWorker() {

            @Nullable
            public Object construct() {
                try {
                    if (progressMonitor.isCanceled()) {
                        return null;
                    }
                    // Parse the input and initialize a "FaceletCube".
                    // The FaceletCube represents the cube by the markings
                    //   of the 54 individual facelets.
                    FaceletCube faceletCube = new FaceletCube();
                    CubeParser cubeParser = new CubeParser();
                    int status = cubeParser.parseInput(Cubes.toNormalizedStickersString(rcube), faceletCube);
                    if (status != CubeParser.VALID) {
                        return new ParseException(cubeParser.getErrorText(status));
                    }

                    // Validate the facelet representation in terms  of
                    //  legal cubie markings, permutation, and parity
                    //   and initialize a "standard" cube.  The standard
                    //   cube represents the cube state in terms of cubie
                    //   permutation and parity.
                    KociembaCube kcube = new KociembaCube();
                    if ((status = faceletCube.validate(kcube)) != FaceletCube.VALID) {
                        return new ParseException(faceletCube.getErrorText(status));
                    }

                    // Create a solver, initialize the move mapping and
                    //   pruning tables, and invoke the search for a
                    //   solution.  Since the cube is in a valid configuration
                    //   at this point, a solution should always be found.
                    Solver solver = new Solver();
                    int result = solver.solve(progressMonitor, kcube, new DefaultNotation());
                    if (result == Solver.ABORT) {
                        return null;
                    } else {
                        SequenceNode solution = solver.getSolution();
                        solution.transformOrientation(cube.getLayerCount(), rcube.getCubeOrientation(), true);
                        return solution;
                    }

                } catch (Throwable e) {
                    return e;
                }

            }

            public void finished(Object result) {
                progressMonitor.complete();
                setEnabled(true);

                if (result instanceof Node) {
                    // The solver was successful.
                    // Convert the solution to a string using a notation.
                    try {
                        Node solution = (Node) result;
                        scriptField.setText(solution.toString(notation));
                        apply(null);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                } else if (result instanceof Throwable) {
                    // The solver failed.
                    // Show an error message.
                    Throwable e = (Throwable) result;
                    JOptionPane.showMessageDialog(
                            RubiksCubeSolverDemo.this,
                            "<html><font face=Dialog><b>Generator failed</b><br><font size=-1>" + e.getMessage(),
                            "Cube Twister: Generate Cube",
                            JOptionPane.ERROR_MESSAGE);
                    e.printStackTrace();
                }

            }
        };

        new Thread(worker).start();

    }//GEN-LAST:event_solve
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton applyButton;
    private javax.swing.JButton resetButton;
    private javax.swing.JTextArea scriptField;
    private javax.swing.JPanel scriptPanel;
    private javax.swing.JScrollPane scriptScrollPane;
    private javax.swing.JButton solveButton;
    // End of variables declaration//GEN-END:variables
}
